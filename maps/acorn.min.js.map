{"version":3,"sources":["acorn.min.js"],"names":["root","mod","exports","module","define","amd","acorn","this","setOptions","opts","options","opt","defaultOptions","Object","prototype","hasOwnProperty","call","sourceFile","raise","pos","message","loc","getLineInfo","input","line","column","err","SyntaxError","raisedAt","tokPos","makePredicate","words","compareTo","arr","length","f","JSON","stringify","i","split","cats","out","j","push","sort","a","b","cat","Function","line_loc_t","tokCurLine","tokLineStart","initTokenState","tokRegexpAllowed","skipSpace","finishToken","type","val","tokEnd","locations","tokEndLoc","tokType","tokVal","beforeExpr","skipBlockComment","startLoc","onComment","start","end","indexOf","lineBreak","lastIndex","match","exec","index","slice","skipLineComment","ch","charCodeAt","inputLen","next","nonASCIIwhitespace","test","String","fromCharCode","readToken_dot","readNumber","_dot","readToken_slash","readRegexp","finishOp","_assign","_slash","readToken_mult_modulo","_multiplyModulo","readToken_pipe_amp","code","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseAND","readToken_caret","_bitwiseXOR","readToken_plus_min","newline","lastEnd","readToken","_incDec","_plusMin","readToken_lt_gt","size","_bitShift","_relational","readToken_eq_excl","_equality","_eq","_prefix","getTokenFromCode","_parenL","_parenR","_semi","_comma","_bracketL","_bracketR","_braceL","_braceR","_colon","_question","readHexNumber","readString","forceRegexp","tokStart","tokStartLoc","_eof","isIdentifierStart","readWord","tok","nonASCIIidentifierStart","str","escaped","inClass","content","charAt","mods","readWord1","_regexp","RegExp","readInt","radix","len","total","e","Infinity","_num","startsWithDot","isFloat","octal","parseFloat","strict","parseInt","quote","_string","readHexChar","n","containsEsc","word","first","isIdentifierChar","esc","escStr","_name","isKeyword","keywordTypes","forbidReserved","ecmaVersion","isReservedWord3","isReservedWord5","isStrictReservedWord","lastStart","lastEndLoc","setStrict","strct","lastIndexOf","node_t","node_loc_t","source","startNode","node","directSourceFile","ranges","range","startNodeFrom","other","finishNode","isUseStrict","stmt","expression","value","eat","canInsertSemicolon","strictSemicolons","semicolon","unexpected","expect","checkLVal","expr","isStrictBadIdWord","name","parseTopLevel","program","inFunction","labels","body","parseStatement","starttype","_break","_continue","isBreak","label","parseIdent","lab","kind","keyword","_debugger","_do","loopLabel","pop","_while","parseParenExpression","_for","parseFor","_var","init","parseVar","declarations","_in","parseForIn","parseExpression","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","discriminant","cases","switchLabel","cur","sawDefault","_case","_default","isCase","_throw","_try","block","parseBlock","handler","_catch","clause","param","guard","guardedHandlers","empty","finalizer","_finally","_with","object","maybeName","isLoop","allowStrict","oldStrict","update","left","right","noIn","decl","id","noComma","parseMaybeAssign","expressions","parseMaybeConditional","isAssign","operator","parseExprOps","parseExprOp","parseMaybeUnary","minPrec","prec","binop","op","prefix","isUpdate","parseExprSubscripts","postfix","parseSubscripts","parseExprAtom","base","noCalls","property","computed","callee","arguments","parseExprList","_this","raw","_null","_true","_false","atomValue","tokStartLoc1","tokStart1","elements","parseObj","_new","parseNew","sawGetSet","properties","allowTrailingCommas","prop","key","parsePropertyName","isGetSet","conflict","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal","version","parse","inpt","offset","tokenize","getToken","t","endLoc","jumpTo","reAllowed","break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","while","with","null","true","false","new","in","instanceof","typeof","void","delete","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","slash","eq","eof","num","regexp","string","kw","nonASCIIidentifierStartChars","nonASCIIidentifier","Interpreter","opt_initFunc","ast","initFunc_","paused_","UNDEFINED","Primitive","undefined","NULL","TRUE","FALSE","NUMBER_ZERO","NUMBER_ONE","STRING_EMPTY","scope","createScope","parent","BOOLEAN","NUMBER","STRING","stateStack","thisExpression","done","appendCode","state","Error","step","run","initGlobalScope","setProperty","createPrimitive","NaN","initFunction","initObject","OBJECT","initArray","initNumber","initString","initBoolean","initDate","initMath","initRegExp","initJSON","initError","wrapper","thisInterpreter","isNaN","toNumber","createNativeFunction","isFinite","toString","func","createObject","FUNCTION","eval","strFunctions","escape","unescape","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","nativeFunc","throwException","URI_ERROR","var_args","newFunc","args","join","parentScope","createFunction","valueOf","newObj","nonenumerable","obj","pseudoList","ARRAY","descriptor","getInt","def","Math","floor","strictComp","isPrimitive","data","newArray","arrayIndex","RANGE_ERROR","tmp","howmany","max","min","removed","opt_begin","opt_end","list","begin","element","getProperty","opt_separator","sep","text","isa","searchElement","opt_fromIndex","fromIndex","opt_compFunc","jsList","numConsts","Number","fractionDigits","toExponential","digits","toFixed","precision","toPrecision","functions","apply","replace","searchValue","compareString","localeCompare","separator","limit","REGEXP","indexA","indexB","substring","substr","beginSlice","endSlice","search","newSubStr","toBoolean","c","d","h","DATE","newDate","bind","Date","getTime","dateString","UTC","getFunctions","setFunctions","myMath","mathConsts","numFunctions","pattern","flags","rgx","createRegExp","result","toPseudoObject","nativeObj","pseudoObject","Array","toNativeObject","myJSON","arg","opt_message","ERROR","newError","errors","EVAL_ERROR","REFERENCE_ERROR","SYNTAX_ERROR","TYPE_ERROR","constName","errorName","child","comp","interpreter","Boolean","fixed","create","strs","global","ignoreCase","multiline","opt_scope","getScope","createAsyncFunction","asyncFunc","hasProperty","TypeError","opt_fixed","opt_nonenum","newLength","deleteProperty","populateScope_","firstNode","createSpecialScope","getValueFromScope","nameStr","setValueToScope","recurse","constructor","thisIterpreter","splice","getValue","setValue","errorClass","error","shift","EvalError","RangeError","ReferenceError","URIError","unshift","throwValue","array","doneLeft","doneRight","leftSide","rightSide","leftValue","rightValue","leftNumber","rightNumber","components","n_","isSwitch","doneCallee_","func_","member_","funcThis_","isConstructor_","doneExec","argsList","paramName","paramValue","funcState","argsWithCallback","concat","evalInterpreter","doneBody","doneVariable_","doneObject_","iterator","variable","mode","doneLeft_","doneRight_","doneProperty_","valueToggle","checked","switchValue","currentCase","doneBlock","doneFinalizer","nextState","changeValue","doneObject"],"mappings":"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","file":"../acorn/acorn.min.js","sourcesContent":["// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports); // CommonJS\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod); // AMD\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.4.1\";\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\n  // (`let`, `yield`, inline XML, etc) is not recognized.\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3 or 5. This\n    // influences support for strict mode, the set of reserved words, and\n    // support for getters and setter.\n    ecmaVersion: 5,\n    // Turn on `strictSemicolons` to prevent the parser from doing\n    // automatic semicolon insertion.\n    strictSemicolons: false,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // By default, reserved words are not enforced. Enable\n    // `forbidReserved` to enforce them.\n    forbidReserved: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `location` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `location` is on or off.\n    directSourceFile: null\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n      options[opt] = defaultOptions[opt];\n    sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return {line: line, column: offset - cur};\n  };\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Acorn parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      readToken(forceRegexp);\n      t.start = tokStart; t.end = tokEnd;\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n      t.type = tokType; t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function(pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `labels` to verify that\n  // `break` and `continue` have somewhere to jump to, and `strict`\n  // indicates whether strict mode is on.\n\n  var inFunction, labels, strict;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  // The keywords that denote values.\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n                      \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n                      \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n                      \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n                      \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n                      \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n                      \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n                      \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n                      \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n                      \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator. `isUpdate` specifies that the node produced by\n  // the operator should be of type UpdateExpression rather than\n  // simply UnaryExpression (`++` and `--`).\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n                      num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\", cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j)\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function(a, b) {return b.length - a.length;});\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n    // Otherwise, simply generate a flat `switch` statement.\n\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The ECMAScript 3 reserved word list.\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  // ECMAScript 5 reserved words.\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  // The additional reserved words in strict mode.\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  // The forbidden variable names in strict mode.\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // And the keywords.\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function line_loc_t() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    skipSpace();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new line_loc_t;\n    tokType = type;\n    skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n    tokPos = end + 2;\n    if (options.locations) {\n      lineBreak.lastIndex = start;\n      var match;\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n        ++tokCurLine;\n        tokLineStart = match.index + match[0].length;\n      }\n    }\n    if (options.onComment)\n      options.onComment(true, input.slice(start + 2, end), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var ch = input.charCodeAt(tokPos+=2);\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n    if (options.onComment)\n      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 32) { // ' '\n        ++tokPos;\n      } else if (ch === 13) {\n        ++tokPos;\n        var next = input.charCodeAt(tokPos);\n        if (next === 10) {\n          ++tokPos;\n        }\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\n        ++tokPos;\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch > 8 && ch < 14) {\n        ++tokPos;\n      } else if (ch === 47) { // '/'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 42) { // '*'\n          skipBlockComment();\n        } else if (next === 47) { // '/'\n          skipLineComment();\n        } else break;\n      } else if (ch === 160) { // '\\xa0'\n        ++tokPos;\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++tokPos;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() { // '/'\n    var next = input.charCodeAt(tokPos + 1);\n    if (tokRegexpAllowed) {++tokPos; return readRegexp();}\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() { // '%*'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) { // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() { // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) { // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) {\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n          newline.test(input.slice(lastEnd, tokPos))) {\n        // A `-->` line comment\n        tokPos += 3;\n        skipLineComment();\n        skipSpace();\n        return readToken();\n      }\n      return finishOp(_incDec, 2);\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) { // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n        input.charCodeAt(tokPos + 3) == 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      tokPos += 4;\n      skipLineComment();\n      skipSpace();\n      return readToken();\n    }\n    if (next === 61)\n      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) { // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n    return finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n    switch(code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n    case 46: // '.'\n      return readToken_dot();\n\n      // Punctuation tokens.\n    case 40: ++tokPos; return finishToken(_parenL);\n    case 41: ++tokPos; return finishToken(_parenR);\n    case 59: ++tokPos; return finishToken(_semi);\n    case 44: ++tokPos; return finishToken(_comma);\n    case 91: ++tokPos; return finishToken(_bracketL);\n    case 93: ++tokPos; return finishToken(_bracketR);\n    case 123: ++tokPos; return finishToken(_braceL);\n    case 125: ++tokPos; return finishToken(_braceR);\n    case 58: ++tokPos; return finishToken(_colon);\n    case 63: ++tokPos; return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n    case 48: // '0'\n      var next = input.charCodeAt(tokPos + 1);\n      if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return readNumber(false);\n\n      // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return readToken_slash(code);\n\n    case 37: case 42: // '%*'\n      return readToken_mult_modulo();\n\n    case 124: case 38: // '|&'\n      return readToken_pipe_amp(code);\n\n    case 94: // '^'\n      return readToken_caret();\n\n    case 43: case 45: // '+-'\n      return readToken_plus_min(code);\n\n    case 60: case 62: // '<>'\n      return readToken_lt_gt(code);\n\n    case 61: case 33: // '=!'\n      return readToken_eq_excl(code);\n\n    case 126: // '~'\n      return finishOp(_prefix, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (!forceRegexp) tokStart = tokPos;\n    else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new line_loc_t;\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\", escaped, inClass, start = tokPos;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;\n        else if (ch === \"]\" && inClass) inClass = false;\n        else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    var content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n    return finishToken(_regexp, new RegExp(content, mods));\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos), val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n      else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) { // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos), val;\n    if (isFloat) val = parseFloat(str);\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n    else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        ++tokPos;\n        return finishToken(_string, out);\n      }\n      if (ch === 92) { // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n        if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\n          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n          case 10: // ' \\n'\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n            break;\n          default: out += String.fromCharCode(ch); break;\n          }\n        }\n      } else {\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n        out += String.fromCharCode(ch); // '\\'\n        ++tokPos;\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word, first = true, start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) { // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n          raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc) {\n      if (isKeyword(word)) type = keywordTypes[word];\n      else if (options.forbidReserved &&\n               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||\n               strict && isStrictReservedWord(word))\n        raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\n    }\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts  that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = lastEnd;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function node_t() {\n    this.type = null;\n    this.start = tokStart;\n    this.end = null;\n  }\n\n  function node_loc_t() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new node_t();\n    if (options.locations)\n      node.loc = new node_loc_t();\n    if (options.directSourceFile)\n      node.sourceFile = options.directSourceFile;\n    if (options.ranges)\n      node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new node_t();\n    node.start = other.start;\n    if (options.locations) {\n      node.loc = new node_loc_t();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges)\n      node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    node.end = lastEnd;\n    if (options.locations)\n      node.loc.end = lastEndLoc;\n    if (options.ranges)\n      node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  function isUseStrict(stmt) {\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  function canInsertSemicolon() {\n    return !options.strictSemicolons &&\n      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  function semicolon() {\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();\n    else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval  something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n      raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new line_loc_t;\n    inFunction = strict = null;\n    labels = [];\n    readToken();\n\n    var node = program || startNode(), first = true;\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && isUseStrict(stmt)) setStrict(true);\n      first = false;\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n      readToken(true);\n\n    var starttype = tokType, node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case _break: case _continue:\n      next();\n      var isBreak = starttype === _break;\n      if (eat(_semi) || canInsertSemicolon()) node.label = null;\n      else if (tokType !== _name) unexpected();\n      else {\n        node.label = parseIdent();\n        semicolon();\n      }\n\n      // Verify that there is an actual destination to break or\n      // continue to.\n      for (var i = 0; i < labels.length; ++i) {\n        var lab = labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n          if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n          if (node.label && isBreak) break;\n        }\n      }\n      if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n      return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n    case _debugger:\n      next();\n      semicolon();\n      return finishNode(node, \"DebuggerStatement\");\n\n    case _do:\n      next();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      expect(_while);\n      node.test = parseParenExpression();\n      semicolon();\n      return finishNode(node, \"DoWhileStatement\");\n\n      // Disambiguating between a `for` and a `for`/`in` loop is\n      // non-trivial. Basically, we have to parse the init `var`\n      // statement or expression, disallowing the `in` operator (see\n      // the second parameter to `parseExpression`), and then check\n      // whether the next token is `in`. When there is no init part\n      // (semicolon immediately after the opening parenthesis), it is\n      // a regular `for` loop.\n\n    case _for:\n      next();\n      labels.push(loopLabel);\n      expect(_parenL);\n      if (tokType === _semi) return parseFor(node, null);\n      if (tokType === _var) {\n        var init = startNode();\n        next();\n        parseVar(init, true);\n        finishNode(init, \"VariableDeclaration\");\n        if (init.declarations.length === 1 && eat(_in))\n          return parseForIn(node, init);\n        return parseFor(node, init);\n      }\n      var init = parseExpression(false, true);\n      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n      return parseFor(node, init);\n\n    case _function:\n      next();\n      return parseFunction(node, true);\n\n    case _if:\n      next();\n      node.test = parseParenExpression();\n      node.consequent = parseStatement();\n      node.alternate = eat(_else) ? parseStatement() : null;\n      return finishNode(node, \"IfStatement\");\n\n    case _return:\n      if (!inFunction) raise(tokStart, \"'return' outside of function\");\n      next();\n\n      // In `return` (and `break`/`continue`), the keywords with\n      // optional arguments, we eagerly look for a semicolon or the\n      // possibility to insert one.\n\n      if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n      else { node.argument = parseExpression(); semicolon(); }\n      return finishNode(node, \"ReturnStatement\");\n\n    case _switch:\n      next();\n      node.discriminant = parseParenExpression();\n      node.cases = [];\n      expect(_braceL);\n      labels.push(switchLabel);\n\n      // Statements under must be grouped (by label) in SwitchCase\n      // nodes. `cur` is used to keep the node that we are currently\n      // adding statements to.\n\n      for (var cur, sawDefault; tokType != _braceR;) {\n        if (tokType === _case || tokType === _default) {\n          var isCase = tokType === _case;\n          if (cur) finishNode(cur, \"SwitchCase\");\n          node.cases.push(cur = startNode());\n          cur.consequent = [];\n          next();\n          if (isCase) cur.test = parseExpression();\n          else {\n            if (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n            cur.test = null;\n          }\n          expect(_colon);\n        } else {\n          if (!cur) unexpected();\n          cur.consequent.push(parseStatement());\n        }\n      }\n      if (cur) finishNode(cur, \"SwitchCase\");\n      next(); // Closing brace\n      labels.pop();\n      return finishNode(node, \"SwitchStatement\");\n\n    case _throw:\n      next();\n      if (newline.test(input.slice(lastEnd, tokStart)))\n        raise(lastEnd, \"Illegal newline after throw\");\n      node.argument = parseExpression();\n      semicolon();\n      return finishNode(node, \"ThrowStatement\");\n\n    case _try:\n      next();\n      node.block = parseBlock();\n      node.handler = null;\n      if (tokType === _catch) {\n        var clause = startNode();\n        next();\n        expect(_parenL);\n        clause.param = parseIdent();\n        if (strict && isStrictBadIdWord(clause.param.name))\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n        expect(_parenR);\n        clause.guard = null;\n        clause.body = parseBlock();\n        node.handler = finishNode(clause, \"CatchClause\");\n      }\n      node.guardedHandlers = empty;\n      node.finalizer = eat(_finally) ? parseBlock() : null;\n      if (!node.handler && !node.finalizer)\n        raise(node.start, \"Missing catch or finally clause\");\n      return finishNode(node, \"TryStatement\");\n\n    case _var:\n      next();\n      parseVar(node);\n      semicolon();\n      return finishNode(node, \"VariableDeclaration\");\n\n    case _while:\n      next();\n      node.test = parseParenExpression();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      return finishNode(node, \"WhileStatement\");\n\n    case _with:\n      if (strict) raise(tokStart, \"'with' in strict mode\");\n      next();\n      node.object = parseParenExpression();\n      node.body = parseStatement();\n      return finishNode(node, \"WithStatement\");\n\n    case _braceL:\n      return parseBlock();\n\n    case _semi:\n      next();\n      return finishNode(node, \"EmptyStatement\");\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n    default:\n      var maybeName = tokVal, expr = parseExpression();\n      if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n        for (var i = 0; i < labels.length; ++i)\n          if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n        labels.push({name: maybeName, kind: kind});\n        node.body = parseStatement();\n        labels.pop();\n        node.label = expr;\n        return finishNode(node, \"LabeledStatement\");\n      } else {\n        node.expression = expr;\n        semicolon();\n        return finishNode(node, \"ExpressionStatement\");\n      }\n    }\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  function parseBlock(allowStrict) {\n    var node = startNode(), first = true, strict = false, oldStrict;\n    node.body = [];\n    expect(_braceL);\n    while (!eat(_braceR)) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && allowStrict && isUseStrict(stmt)) {\n        oldStrict = strict;\n        setStrict(strict = true);\n      }\n      first = false;\n    }\n    if (strict && !oldStrict) setStrict(false);\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  function parseFor(node, init) {\n    node.init = init;\n    expect(_semi);\n    node.test = tokType === _semi ? null : parseExpression();\n    expect(_semi);\n    node.update = tokType === _parenR ? null : parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` loop.\n\n  function parseForIn(node, init) {\n    node.left = init;\n    node.right = parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForInStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  function parseVar(node, noIn) {\n    node.declarations = [];\n    node.kind = \"var\";\n    for (;;) {\n      var decl = startNode();\n      decl.id = parseIdent();\n      if (strict && isStrictBadIdWord(decl.id.name))\n        raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n      if (!eat(_comma)) break;\n    }\n    return node;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    var expr = parseMaybeAssign(noIn);\n    if (!noComma && tokType === _comma) {\n      var node = startNodeFrom(expr);\n      node.expressions = [expr];\n      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n      return finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeConditional(noIn);\n    if (tokType.isAssign) {\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeAssign(noIn);\n      checkLVal(left);\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  function parseMaybeConditional(noIn) {\n    var expr = parseExprOps(noIn);\n    if (eat(_question)) {\n      var node = startNodeFrom(expr);\n      node.test = expr;\n      node.consequent = parseExpression(true);\n      expect(_colon);\n      node.alternate = parseExpression(true, noIn);\n      return finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  function parseExprOp(left, minPrec, noIn) {\n    var prec = tokType.binop;\n    if (prec != null && (!noIn || tokType !== _in)) {\n      if (prec > minPrec) {\n        var node = startNodeFrom(left);\n        node.left = left;\n        node.operator = tokVal;\n        var op = tokType;\n        next();\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  function parseMaybeUnary() {\n    if (tokType.prefix) {\n      var node = startNode(), update = tokType.isUpdate;\n      node.operator = tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseMaybeUnary();\n      if (update) checkLVal(node.argument);\n      else if (strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        raise(node.start, \"Deleting local variable in strict mode\");\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n    var expr = parseExprSubscripts();\n    while (tokType.postfix && !canInsertSemicolon()) {\n      var node = startNodeFrom(expr);\n      node.operator = tokVal;\n      node.prefix = false;\n      node.argument = expr;\n      checkLVal(expr);\n      next();\n      expr = finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseExprSubscripts() {\n    return parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n    if (eat(_dot)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseIdent(true);\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseExpression();\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      var node = startNodeFrom(base);\n      node.callee = base;\n      node.arguments = parseExprList(_parenR, false);\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n    } else return base;\n  }\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n    case _this:\n      var node = startNode();\n      next();\n      return finishNode(node, \"ThisExpression\");\n    case _name:\n      return parseIdent();\n    case _num: case _string: case _regexp:\n      var node = startNode();\n      node.value = tokVal;\n      node.raw = input.slice(tokStart, tokEnd);\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _null: case _true: case _false:\n      var node = startNode();\n      node.value = tokType.atomValue;\n      node.raw = tokType.keyword;\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _parenL:\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n      next();\n      var val = parseExpression();\n      val.start = tokStart1;\n      val.end = tokEnd;\n      if (options.locations) {\n        val.loc.start = tokStartLoc1;\n        val.loc.end = tokEndLoc;\n      }\n      if (options.ranges)\n        val.range = [tokStart1, tokEnd];\n      expect(_parenR);\n      return val;\n\n    case _bracketL:\n      var node = startNode();\n      next();\n      node.elements = parseExprList(_bracketR, true, true);\n      return finishNode(node, \"ArrayExpression\");\n\n    case _braceL:\n      return parseObj();\n\n    case _function:\n      var node = startNode();\n      next();\n      return parseFunction(node, false);\n\n    case _new:\n      return parseNew();\n\n    default:\n      unexpected();\n    }\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument\n  // to be a `[]` or dot subscript expression, but not a call  at\n  // least, not without wrapping it in parentheses. Thus, it uses the\n\n  function parseNew() {\n    var node = startNode();\n    next();\n    node.callee = parseSubscripts(parseExprAtom(), true);\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n    else node.arguments = empty;\n    return finishNode(node, \"NewExpression\");\n  }\n\n  // Parse an object literal.\n\n  function parseObj() {\n    var node = startNode(), first = true, sawGetSet = false;\n    node.properties = [];\n    next();\n    while (!eat(_braceR)) {\n      if (!first) {\n        expect(_comma);\n        if (options.allowTrailingCommas && eat(_braceR)) break;\n      } else first = false;\n\n      var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n      if (eat(_colon)) {\n        prop.value = parseExpression(true);\n        kind = prop.kind = \"init\";\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n        isGetSet = sawGetSet = true;\n        kind = prop.kind = prop.key.name;\n        prop.key = parsePropertyName();\n        if (tokType !== _parenL) unexpected();\n        prop.value = parseFunction(startNode(), false);\n      } else unexpected();\n\n      // getters and setters are not allowed to clash  either with\n      // each other or with an init property  and in strict mode,\n      // init properties are also not allowed to be repeated.\n\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var other = node.properties[i];\n          if (other.key.name === prop.key.name) {\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n              kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\n          }\n        }\n      }\n      node.properties.push(prop);\n    }\n    return finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  function parseFunction(node, isStatement) {\n    if (tokType === _name) node.id = parseIdent();\n    else if (isStatement) unexpected();\n    else node.id = null;\n    node.params = [];\n    var first = true;\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma); else first = false;\n      node.params.push(parseIdent());\n    }\n\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = inFunction, oldLabels = labels;\n    inFunction = true; labels = [];\n    node.body = parseBlock(true);\n    inFunction = oldInFunc; labels = oldLabels;\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n        var id = i < 0 ? node.id : node.params[i];\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n          raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n          raise(id.start, \"Argument name clash in strict mode\");\n      }\n    }\n\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [], first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);\n      else elts.push(parseExpression(true));\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n\n});\n\n/**\n * @license\n * JavaScript Interpreter\n *\n * Copyright 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript.\n * @author fraser@google.com (Neil Fraser)\n */\n'use strict';\n\n/**\n * Create a new interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n * @param {Function} opt_initFunc Optional initialization function.  Used to\n *     define APIs.  When called it is passed the interpreter object and the\n *     global scope object.\n * @constructor\n */\nvar Interpreter = function(code, opt_initFunc) {\n  if (typeof code == 'string') {\n    code = acorn.parse(code);\n  }\n  this.ast = code;\n  this.initFunc_ = opt_initFunc;\n  this.paused_ = false;\n  // Predefine some common primitives for performance.\n  this.UNDEFINED = new Interpreter.Primitive(undefined, this);\n  this.NULL = new Interpreter.Primitive(null, this);\n  this.TRUE = new Interpreter.Primitive(true, this);\n  this.FALSE = new Interpreter.Primitive(false, this);\n  this.NUMBER_ZERO = new Interpreter.Primitive(0, this);\n  this.NUMBER_ONE = new Interpreter.Primitive(1, this);\n  this.STRING_EMPTY = new Interpreter.Primitive('', this);\n  var scope = this.createScope(this.ast, null);\n  // Fix the parent properties now that the global scope exists.\n  //this.UNDEFINED.parent = undefined;\n  //this.NULL.parent = undefined;\n  this.TRUE.parent = this.BOOLEAN;\n  this.FALSE.parent = this.BOOLEAN;\n  this.NUMBER_ZERO.parent = this.NUMBER;\n  this.NUMBER_ONE.parent = this.NUMBER;\n  this.STRING_EMPTY.parent = this.STRING;\n  this.stateStack = [{\n    node: this.ast,\n    scope: scope,\n    thisExpression: scope,\n    done: false\n  }];\n};\n\n/**\n * Add more code to the interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n */\nInterpreter.prototype.appendCode = function(code) {\n  var state = this.stateStack[this.stateStack.length - 1];\n  if (!state || state.node.type != 'Program') {\n    throw Error('Expecting original AST to start with a Program node.');\n  }\n  if (typeof code == 'string') {\n    code = acorn.parse(code);\n  }\n  if (!code || code.type != 'Program') {\n    throw Error('Expecting new AST to start with a Program node.');\n  }\n  // Append the new program to the old one.\n  for (var i = 0, node; node = code.body[i]; i++) {\n    state.node.body.push(node);\n  }\n  state.done = false;\n};\n\n/**\n * Execute one step of the interpreter.\n * @return {boolean} True if a step was executed, false if no more instructions.\n */\nInterpreter.prototype.step = function() {\n  var state = this.stateStack[0];\n  if (!state || state.node.type == 'Program' && state.done) {\n    return false;\n  } else if (this.paused_) {\n    return true;\n  }\n  this['step' + state.node.type]();\n  return true;\n};\n\n/**\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\n * @return {boolean} True if a execution is asynchonously blocked,\n *     false if no more instructions.\n */\nInterpreter.prototype.run = function() {\n  while (!this.paused_ && this.step()) {}\n  return this.paused_;\n};\n\n/**\n * Initialize the global scope with buitin properties and functions.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initGlobalScope = function(scope) {\n  // Initialize uneditable global properties.\n  this.setProperty(scope, 'Infinity', this.createPrimitive(Infinity), true);\n  this.setProperty(scope, 'NaN', this.createPrimitive(NaN), true);\n  this.setProperty(scope, 'undefined', this.UNDEFINED, true);\n  this.setProperty(scope, 'window', scope, true);\n  this.setProperty(scope, 'self', scope, false); // Editable.\n\n  // Initialize global objects.\n  this.initFunction(scope);\n  this.initObject(scope);\n  // Unable to set scope's parent prior (this.OBJECT did not exist).\n  scope.parent = this.OBJECT;\n  this.initArray(scope);\n  this.initNumber(scope);\n  this.initString(scope);\n  this.initBoolean(scope);\n  this.initDate(scope);\n  this.initMath(scope);\n  this.initRegExp(scope);\n  this.initJSON(scope);\n  this.initError(scope);\n\n  // Initialize global functions.\n  var thisInterpreter = this;\n  var wrapper;\n  wrapper = function(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isNaN(num.toNumber()));\n  };\n  this.setProperty(scope, 'isNaN',\n                   this.createNativeFunction(wrapper));\n  wrapper = function(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isFinite(num.toNumber()));\n  };\n  this.setProperty(scope, 'isFinite',\n                   this.createNativeFunction(wrapper));\n  wrapper = function(str) {\n    str = str || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(parseFloat(str.toNumber()));\n  };\n  this.setProperty(scope, 'parseFloat',\n                   this.createNativeFunction(wrapper));\n  wrapper = function(str, radix) {\n    str = str || thisInterpreter.UNDEFINED;\n    radix = radix || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(\n        parseInt(str.toString(), radix.toNumber()));\n  };\n  this.setProperty(scope, 'parseInt',\n                   this.createNativeFunction(wrapper));\n\n  var func = this.createObject(this.FUNCTION);\n  func.eval = true;\n  this.setProperty(func, 'length', this.NUMBER_ONE, true);\n  this.setProperty(scope, 'eval', func);\n\n  var strFunctions = [\n    [escape, 'escape'], [unescape, 'unescape'],\n    [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'],\n    [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']\n  ];\n  for (var i = 0; i < strFunctions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function(str) {\n        str = (str || thisInterpreter.UNDEFINED).toString();\n        try {\n          str = nativeFunc(str);\n        } catch (e) {\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\n        }\n        return thisInterpreter.createPrimitive(str);\n      };\n    })(strFunctions[i][0]);\n    this.setProperty(scope, strFunctions[i][1],\n                     this.createNativeFunction(wrapper));\n  }\n\n  // Run any user-provided initialization.\n  if (this.initFunc_) {\n    this.initFunc_(this, scope);\n  }\n};\n\n/**\n * Initialize the Function class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initFunction = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Function constructor.\n  wrapper = function(var_args) {\n    if (this.parent == thisInterpreter.FUNCTION) {\n      // Called with new.\n      var newFunc = this;\n    } else {\n      var newFunc = thisInterpreter.createObject(thisInterpreter.FUNCTION);\n    }\n    if (arguments.length) {\n      var code = arguments[arguments.length - 1].toString();\n    } else {\n      var code = '';\n    }\n    var args = [];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      args.push(arguments[i].toString());\n    }\n    args = args.join(', ');\n    if (args.indexOf(')') != -1) {\n      throw SyntaxError('Function arg string contains parenthesis');\n    }\n    // Interestingly, the scope for constructed functions is the global scope,\n    // even if they were constructed in some other scope.\n    newFunc.parentScope =\n        thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1].scope;\n    var ast = acorn.parse('$ = function(' + args + ') {' + code + '};');\n    newFunc.node = ast.body[0].expression.right;\n    thisInterpreter.setProperty(newFunc, 'length',\n        thisInterpreter.createPrimitive(newFunc.node.length), true);\n    return newFunc;\n  };\n  this.FUNCTION = this.createObject(null);\n  this.setProperty(scope, 'Function', this.FUNCTION);\n  // Manually setup type and prototype because createObj doesn't recognize\n  // this object as a function (this.FUNCTION did not exist).\n  this.FUNCTION.type = 'function';\n  this.setProperty(this.FUNCTION, 'prototype', this.createObject(null));\n  this.FUNCTION.nativeFunc = wrapper;\n\n  // Create stub functions for apply and call.\n  // These are processed as special cases in stepCallExpression.\n  var node = {\n    type: 'FunctionApply_',\n    params: [],\n    id: null,\n    body: null,\n    start: 0,\n    end: 0\n  };\n  this.setProperty(this.FUNCTION.properties.prototype, 'apply',\n                   this.createFunction(node, {}), false, true);\n  node = {\n    type: 'FunctionCall_',\n    params: [],\n    id: null,\n    body: null,\n    start: 0,\n    end: 0\n  };\n  this.setProperty(this.FUNCTION.properties.prototype, 'call',\n                   this.createFunction(node, {}), false, true);\n\n  // Function has no parent to inherit from, so it needs its own mandatory\n  // toString and valueOf functions.\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setProperty(this.FUNCTION.properties.prototype, 'toString',\n                   this.createNativeFunction(wrapper), false, true);\n  this.setProperty(this.FUNCTION, 'toString',\n                   this.createNativeFunction(wrapper), false, true);\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setProperty(this.FUNCTION.properties.prototype, 'valueOf',\n                   this.createNativeFunction(wrapper), false, true);\n  this.setProperty(this.FUNCTION, 'valueOf',\n                   this.createNativeFunction(wrapper), false, true);\n};\n\n/**\n * Initialize the Object class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initObject = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Object constructor.\n  wrapper = function(var_args) {\n    if (this.parent == thisInterpreter.OBJECT) {\n      // Called with new.\n      var newObj = this;\n    } else {\n      var newObj = thisInterpreter.createObject(thisInterpreter.OBJECT);\n    }\n    return newObj;\n  };\n  this.OBJECT = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Object', this.OBJECT);\n\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setProperty(this.OBJECT.properties.prototype, 'toString',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setProperty(this.OBJECT.properties.prototype, 'valueOf',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(prop) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    for (var key in this.properties) {\n      if (key == prop) {\n        return thisInterpreter.TRUE;\n      }\n    }\n    return thisInterpreter.FALSE;\n  };\n  this.setProperty(this.OBJECT.properties.prototype, 'hasOwnProperty',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(key) {\n    key = (key || thisInterpreter.UNDEFINED).toString();\n    return thisInterpreter.createPrimitive(!(key in this.nonenumerable));\n  };\n  this.setProperty(this.OBJECT.properties.prototype, 'propertyIsEnumerable',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      if (key in obj.nonenumerable) {\n        continue;\n      }\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'keys',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(obj, prop, descriptor) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    if (!(descriptor instanceof Interpreter.Object)) {\n      throw Error('Property description must be an object.');\n    }\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'defineProperty',\n                   this.createNativeFunction(wrapper), false, true);\n};\n\n/**\n * Initialize the Array class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initArray = function(scope) {\n  var thisInterpreter = this;\n  var getInt = function(obj, def) {\n    // Return an integer, or the default.\n    var n = obj ? Math.floor(obj.toNumber()) : def;\n    if (isNaN(n)) {\n      n = def;\n    }\n    return n;\n  };\n  var strictComp = function(a, b) {\n    // Strict === comparison.\n    if (a.isPrimitive && b.isPrimitive) {\n      return a.data === b.data;\n    }\n    return a === b;\n  };\n  var wrapper;\n  // Array constructor.\n  wrapper = function(var_args) {\n    if (this.parent == thisInterpreter.ARRAY) {\n      // Called with new.\n      var newArray = this;\n    } else {\n      var newArray = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    }\n    var first = arguments[0];\n    if (first && first.type == 'number') {\n      if (isNaN(thisInterpreter.arrayIndex(first))) {\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR,\n                                       'Invalid array length');\n      }\n      newArray.length = first.data;\n    } else {\n      for (var i = 0; i < arguments.length; i++) {\n        newArray.properties[i] = arguments[i];\n      }\n      newArray.length = i;\n    }\n    return newArray;\n  };\n  this.ARRAY = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Array', this.ARRAY);\n\n  wrapper = function() {\n    if (this.length) {\n      var value = this.properties[this.length - 1];\n      delete this.properties[this.length - 1];\n      this.length--;\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'pop',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[this.length] = arguments[i];\n      this.length++;\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'push',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function() {\n    if (this.length) {\n      var value = this.properties[0];\n      for (var i = 1; i < this.length; i++) {\n        this.properties[i - 1] = this.properties[i];\n      }\n      this.length--;\n      delete this.properties[this.length];\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'shift',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(var_args) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      this.properties[i + arguments.length] = this.properties[i];\n    }\n    this.length += arguments.length;\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[i] = arguments[i];\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'unshift',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function() {\n    for (var i = 0; i < this.length / 2; i++) {\n      var tmp = this.properties[this.length - i - 1];\n      this.properties[this.length - i - 1] = this.properties[i];\n      this.properties[i] = tmp;\n    }\n    return thisInterpreter.UNDEFINED;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'reverse',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(index, howmany, var_args) {\n    index = getInt(index, 0);\n    if (index < 0) {\n      index = Math.max(this.length + index, 0);\n    } else {\n      index = Math.min(index, this.length);\n    }\n    howmany = getInt(howmany, Infinity);\n    howmany = Math.min(howmany, this.length - index);\n    var removed = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    // Remove specified elements.\n    for (var i = index; i < index + howmany; i++) {\n      removed.properties[removed.length++] = this.properties[i];\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Move other element to fill the gap.\n    for (var i = index + howmany; i < this.length - howmany; i++) {\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Delete superfluous properties.\n    for (var i = this.length - howmany; i < this.length; i++) {\n      delete this.properties[i];\n    }\n    this.length -= howmany;\n    // Insert specified items.\n    for (var i = this.length - 1; i >= index; i--) {\n      this.properties[i + arguments.length - 2] = this.properties[i];\n    }\n    this.length += arguments.length - 2;\n    for (var i = 2; i < arguments.length; i++) {\n      this.properties[index + i - 2] = arguments[i];\n    }\n    return removed;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'splice',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(opt_begin, opt_end) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var begin = getInt(opt_begin, 0);\n    if (begin < 0) {\n      begin = this.length + begin;\n    }\n    begin = Math.max(0, Math.min(begin, this.length));\n    var end = getInt(opt_end, this.length);\n    if (end < 0) {\n      end = this.length + end;\n    }\n    end = Math.max(0, Math.min(end, this.length));\n    var length = 0;\n    for (var i = begin; i < end; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    return list;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'slice',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(opt_separator) {\n    if (!opt_separator || opt_separator.data === undefined) {\n      var sep = undefined;\n    } else {\n      var sep = opt_separator.toString();\n    }\n    var text = [];\n    for (var i = 0; i < this.length; i++) {\n      text[i] = this.properties[i];\n    }\n    return thisInterpreter.createPrimitive(text.join(sep));\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'join',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(var_args) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var length = 0;\n    // Start by copying the current array.\n    for (var i = 0; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    // Loop through all arguments and copy them in.\n    for (var i = 0; i < arguments.length; i++) {\n      var value = arguments[i];\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\n        for (var j = 0; j < value.length; j++) {\n          var element = thisInterpreter.getProperty(value, j);\n          thisInterpreter.setProperty(list, length++, element);\n        }\n      } else {\n        thisInterpreter.setProperty(list, length++, value);\n      }\n    }\n    return list;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'concat',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, 0);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.max(0, fromIndex);\n    for (var i = fromIndex; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'indexOf',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, this.length);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.min(fromIndex, this.length - 1);\n    for (var i = fromIndex; i >= 0; i--) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'lastIndexOf',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(opt_compFunc) {\n    var jsList = [];\n    for (var i = 0; i < this.length; i++) {\n      jsList[i] = this.properties[i];\n    }\n    // TODO: Add custom sort comparison function(opt_compFunc).\n    jsList.sort();\n    for (var i = 0; i < jsList.length; i++) {\n      thisInterpreter.setProperty(this, i, jsList[i]);\n    }\n    return this;\n  };\n  this.setProperty(this.ARRAY.properties.prototype, 'sort',\n                   this.createNativeFunction(wrapper), false, true);\n};\n\n/**\n * Initialize the Number class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initNumber = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Number constructor.\n  wrapper = function(value) {\n    value = value ? value.toNumber() : 0;\n    if (this.parent != thisInterpreter.NUMBER) {\n      // Called as Number().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Number().\n    this.data = value;\n    return this;\n  };\n  this.NUMBER = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Number', this.NUMBER);\n\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY',\n                   'POSITIVE_INFINITY'];\n  for (var i = 0; i < numConsts.length; i++) {\n    this.setProperty(this.NUMBER, numConsts[i],\n                     this.createPrimitive(Number[numConsts[i]]));\n  }\n\n  wrapper = function(fractionDigits) {\n    fractionDigits = fractionDigits ? fractionDigits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toExponential(fractionDigits));\n  };\n  this.setProperty(this.NUMBER.properties.prototype, 'toExponential',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(digits) {\n    digits = digits ? digits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toFixed(digits));\n  };\n  this.setProperty(this.NUMBER.properties.prototype, 'toFixed',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(precision) {\n    precision = precision ? precision.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toPrecision(precision));\n  };\n  this.setProperty(this.NUMBER.properties.prototype, 'toPrecision',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(radix) {\n    radix = radix ? radix.toNumber() : 10;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toString(radix));\n  };\n  this.setProperty(this.NUMBER.properties.prototype, 'toString',\n                   this.createNativeFunction(wrapper), false, true);\n};\n\n/**\n * Initialize the String class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initString = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // String constructor.\n  wrapper = function(value) {\n    value = value ? value.toString() : '';\n    if (this.parent != thisInterpreter.STRING) {\n      // Called as String().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new String().\n    this.data = value;\n    return this;\n  };\n  this.STRING = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'String', this.STRING);\n\n  var functions = ['toLowerCase', 'toUpperCase',\n                   'toLocaleLowerCase', 'toLocaleUpperCase'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function() {\n        return thisInterpreter.createPrimitive(nativeFunc.apply(this));\n      };\n    })(String.prototype[functions[i]]);\n    this.setProperty(this.STRING.properties.prototype, functions[i],\n                     this.createNativeFunction(wrapper), false, true);\n  }\n\n  // Trim function may not exist in host browser.  Write them from scratch.\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+|\\s+$/g, ''));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'trim',\n                   this.createNativeFunction(wrapper), false, true);\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+/g, ''));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'trimLeft',\n                   this.createNativeFunction(wrapper), false, true);\n  wrapper = function() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/\\s+$/g, ''));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'trimRight',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(num) {\n    var str = this.toString();\n    num = (num || thisInterpreter.UNDEFINED).toNumber();\n    return thisInterpreter.createPrimitive(str.charAt(num));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'charAt',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(num) {\n    var str = this.toString();\n    num = (num || thisInterpreter.UNDEFINED).toNumber();\n    return thisInterpreter.createPrimitive(str.charCodeAt(num));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'charCodeAt',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(\n        str.indexOf(searchValue, fromIndex));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'indexOf',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(\n        str.lastIndexOf(searchValue, fromIndex));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'lastIndexOf',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(compareString) {\n    var str = this.toString();\n    compareString = (compareString || thisInterpreter.UNDEFINED).toString();\n    return thisInterpreter.createPrimitive(str.localeCompare(compareString));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'localeCompare',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(separator, limit) {\n    var str = this.toString();\n    if (separator) {\n      separator = thisInterpreter.isa(separator, thisInterpreter.REGEXP) ?\n          separator.data : separator.toString();\n    } else { // is this really necessary?\n      separator = undefined;\n    }\n    limit = limit ? limit.toNumber() : undefined;\n    var jsList = str.split(separator, limit);\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < jsList.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(jsList[i]));\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.STRING.properties.prototype, 'split',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(indexA, indexB) {\n    var str = this.toString();\n    indexA = indexA ? indexA.toNumber() : undefined;\n    indexB = indexB ? indexB.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(str.substring(indexA, indexB));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'substring',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(start, length) {\n    var str = this.toString();\n    start = start ? start.toNumber() : undefined;\n    length = length ? length.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(str.substr(start, length));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'substr',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(var_args) {\n    var str = this.toString();\n    for (var i = 0; i < arguments.length; i++) {\n      str += arguments[i].toString();\n    }\n    return thisInterpreter.createPrimitive(str);\n  };\n  this.setProperty(this.STRING.properties.prototype, 'concat',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(beginSlice, endSlice) {\n    var str = this.toString();\n    beginSlice = beginSlice ? beginSlice.toNumber() : undefined;\n    endSlice = endSlice ? endSlice.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(str.slice(beginSlice, endSlice));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'slice',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    var match = str.match(regexp);\n    if (match === null) {\n      return thisInterpreter.NULL;\n    }\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < match.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i,\n          thisInterpreter.createPrimitive(match[i]));\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.STRING.properties.prototype, 'match',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    return thisInterpreter.createPrimitive(str.search(regexp));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'search',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(substr, newSubStr) {\n    var str = this.toString();\n    substr = (substr || thisInterpreter.UNDEFINED).valueOf();\n    newSubStr = (newSubStr || thisInterpreter.UNDEFINED).toString();\n    return thisInterpreter.createPrimitive(str.replace(substr, newSubStr));\n  };\n  this.setProperty(this.STRING.properties.prototype, 'replace',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      arguments[i] = arguments[i].toNumber();\n    }\n    return thisInterpreter.createPrimitive(\n        String.fromCharCode.apply(String, arguments));\n  };\n  this.setProperty(this.STRING, 'fromCharCode',\n                   this.createNativeFunction(wrapper), false, true);\n\n};\n\n/**\n * Initialize the Boolean class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initBoolean = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Boolean constructor.\n  wrapper = function(value) {\n    value = value ? value.toBoolean() : false;\n    if (this.parent != thisInterpreter.BOOLEAN) {\n      // Called as Boolean().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Boolean().\n    this.data = value;\n    return this;\n  };\n  this.BOOLEAN = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\n};\n\n/**\n * Initialize the Date class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initDate = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Date constructor.\n  wrapper = function(a, b, c, d, e, f, h) {\n    if (this.parent == thisInterpreter.DATE) {\n      // Called with new.\n      var newDate = this;\n    } else {\n      var newDate = thisInterpreter.createObject(thisInterpreter.DATE);\n    }\n    if (!arguments.length) {\n      newDate.data = new Date();\n    } else if (arguments.length == 1 && (a.type == 'string' ||\n        thisInterpreter.isa(a, thisInterpreter.STRING))) {\n      newDate.data = new Date(a.toString());\n    } else {\n      var args = [null];\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i] ? arguments[i].toNumber() : undefined;\n      }\n      newDate.data = new (Function.prototype.bind.apply(Date, args));\n    }\n    return newDate;\n  };\n  this.DATE = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Date', this.DATE);\n\n  // Static methods on Date.\n  wrapper = function() {\n    return thisInterpreter.createPrimitive(new Date().getTime());\n  };\n  this.setProperty(this.DATE, 'now',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(dateString) {\n    dateString = dateString ? dateString.toString() : undefined;\n    return thisInterpreter.createPrimitive(Date.parse(dateString));\n  };\n  this.setProperty(this.DATE, 'parse',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(a, b, c, d, e, f, h) {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i] ? arguments[i].toNumber() : undefined;\n    }\n    return thisInterpreter.createPrimitive(Date.UTC.apply(Date, args));\n  };\n  this.setProperty(this.DATE, 'UTC',\n                   this.createNativeFunction(wrapper), false, true);\n\n  // Getter methods.\n  var getFunctions = ['getDate', 'getDay', 'getFullYear', 'getHours',\n      'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime',\n      'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear',\n      'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth',\n      'getUTCSeconds', 'getYear'];\n  for (var i = 0; i < getFunctions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function() {\n        return thisInterpreter.createPrimitive(this.data[nativeFunc]());\n      };\n    })(getFunctions[i]);\n    this.setProperty(this.DATE.properties.prototype, getFunctions[i],\n                     this.createNativeFunction(wrapper), false, true);\n  }\n\n  // Setter methods.\n  var setFunctions = ['setDate', 'setFullYear', 'setHours', 'setMilliseconds',\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate',\n      'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes',\n      'setUTCMonth', 'setUTCSeconds', 'setYear'];\n  for (var i = 0; i < setFunctions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function(var_args) {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args[i] = arguments[i] ? arguments[i].toNumber() : undefined;\n        }\n        return thisInterpreter.createPrimitive(\n            this.data[nativeFunc].apply(this.data, args));\n      };\n    })(setFunctions[i]);\n    this.setProperty(this.DATE.properties.prototype, setFunctions[i],\n                     this.createNativeFunction(wrapper), false, true);\n  }\n\n  // Conversion getter methods.\n  getFunctions = ['toDateString', 'toISOString', 'toGMTString',\n      'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString',\n      'toTimeString', 'toUTCString'];\n  for (var i = 0; i < getFunctions.length; i++) {\n    wrapper = (function(nativeFunc) {\n      return function() {\n        return thisInterpreter.createPrimitive(this.data[nativeFunc]());\n      };\n    })(getFunctions[i]);\n    this.setProperty(this.DATE.properties.prototype, getFunctions[i],\n                     this.createNativeFunction(wrapper), false, true);\n  }\n};\n\n/**\n * Initialize Math object.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initMath = function(scope) {\n  var thisInterpreter = this;\n  var myMath = this.createObject(this.OBJECT);\n  this.setProperty(scope, 'Math', myMath);\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI',\n                    'SQRT1_2', 'SQRT2'];\n  for (var i = 0; i < mathConsts.length; i++) {\n    this.setProperty(myMath, mathConsts[i],\n        this.createPrimitive(Math[mathConsts[i]]), false, true);\n  }\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',\n                      'exp', 'floor', 'log', 'max', 'min', 'pow', 'random',\n                      'round', 'sin', 'sqrt', 'tan'];\n  for (var i = 0; i < numFunctions.length; i++) {\n    var wrapper = (function(nativeFunc) {\n      return function() {\n        for (var j = 0; j < arguments.length; j++) {\n          arguments[j] = arguments[j].toNumber();\n        }\n        return thisInterpreter.createPrimitive(\n            nativeFunc.apply(Math, arguments));\n      };\n    })(Math[numFunctions[i]]);\n    this.setProperty(myMath, numFunctions[i],\n        this.createNativeFunction(wrapper), false, true);\n  }\n};\n\n/**\n * Initialize Regular Expression object.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initRegExp = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Regex constructor.\n  wrapper = function(pattern, flags) {\n    if (this.parent == thisInterpreter.REGEXP) {\n      // Called with new.\n      var rgx = this;\n    } else {\n      var rgx = thisInterpreter.createObject(thisInterpreter.REGEXP);\n    }\n    pattern = pattern ? pattern.toString() : '';\n    flags = flags ? flags.toString() : '';\n    thisInterpreter.createRegExp(rgx, new RegExp(pattern, flags));\n    return rgx;\n  };\n  this.REGEXP = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'RegExp', this.REGEXP);\n\n  wrapper = function(str) {\n    str = str.toString();\n    return thisInterpreter.createPrimitive(this.data.test(str));\n  };\n  this.setProperty(this.REGEXP.properties.prototype, 'test',\n                   this.createNativeFunction(wrapper), false, true);\n\n  wrapper = function(str) {\n    str = str.toString();\n    // Get lastIndex from wrapped regex, since this is settable.\n    this.data.lastIndex =\n        thisInterpreter.getProperty(this, 'lastIndex').toNumber();\n    var match = this.data.exec(str);\n    thisInterpreter.setProperty(this, 'lastIndex',\n        thisInterpreter.createPrimitive(this.data.lastIndex));\n\n    if (match) {\n      var result = thisInterpreter.createObject(thisInterpreter.ARRAY);\n      for (var i = 0; i < match.length; i++) {\n        thisInterpreter.setProperty(result, i,\n            thisInterpreter.createPrimitive(match[i]));\n      }\n      // match has additional properties.\n      thisInterpreter.setProperty(result, 'index',\n          thisInterpreter.createPrimitive(match.index));\n      thisInterpreter.setProperty(result, 'input',\n          thisInterpreter.createPrimitive(match.input));\n      return result;\n    }\n    return thisInterpreter.NULL;\n  };\n  this.setProperty(this.REGEXP.properties.prototype, 'exec',\n                   this.createNativeFunction(wrapper), false, true);\n};\n\n/**\n * Initialize JSON object.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initJSON = function(scope) {\n  var thisInterpreter = this;\n  var myJSON = thisInterpreter.createObject(this.OBJECT);\n  this.setProperty(scope, 'JSON', myJSON);\n\n  /**\n   * Converts from native JS value to a JS interpreter object.\n   * @param {*} nativeObj The native JS object to be converted.\n   * @return {!Object} The equivalent this.OBJECT.\n   */\n  function toPseudoObject(nativeObj) {\n    if (typeof nativeObj !== 'object') {\n      return thisInterpreter.createPrimitive(nativeObj);\n    }\n    var pseudoObject;\n    if (nativeObj instanceof Array) { // Array.\n      pseudoObject = thisInterpreter.createObject(thisInterpreter.ARRAY);\n      for (var i = 0; i < nativeObj.length; i++) {\n        thisInterpreter.setProperty(pseudoObject, i,\n                                    toPseudoObject(nativeObj[i]));\n      }\n    } else { // Object.\n      pseudoObject = thisInterpreter.createObject(thisInterpreter.OBJECT);\n      for (var key in nativeObj) {\n        thisInterpreter.setProperty(pseudoObject, key,\n                                    toPseudoObject(nativeObj[key]));\n      }\n    }\n    return pseudoObject;\n  }\n\n  var wrapper = (function(nativeFunc) {\n    return function() {\n      var arg = arguments[0].data;\n      var nativeObj = nativeFunc.call(JSON, arg);\n      return toPseudoObject(nativeObj);\n    };\n  })(JSON.parse);\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper));\n\n  /**\n   * Converts from this.OBJECT object to native JS object.\n   * @param {!Object} obj The this.OBJECT object to be converted.\n   * @return {*} The equivalent native JS object or value.\n   */\n  function toNativeObject(obj) {\n    if (obj.isPrimitive) {\n      return obj.data;\n    }\n\n    var nativeObj;\n    if (obj.length) { // Array.\n      nativeObj = [];\n      for (var i = 0; i < obj.length; i++) {\n        nativeObj[i] = toNativeObject(obj.properties[i]);\n      }\n    } else { // Object.\n      nativeObj = {};\n      for (var key in obj.properties) {\n        nativeObj[key] = toNativeObject(obj.properties[key]);\n      }\n    }\n\n    return nativeObj;\n  }\n\n  wrapper = (function(nativeFunc) {\n    return function() {\n      var arg = toNativeObject(arguments[0]);\n      return thisInterpreter.createPrimitive(nativeFunc.call(JSON, arg));\n    };\n  })(JSON.stringify);\n  this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper));\n};\n\n/**\n * Initialize the Error class.\n * @param {!Object} scope Global scope.\n */\nInterpreter.prototype.initError = function(scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Error constructor.\n  wrapper = function(opt_message) {\n    if (this.parent == thisInterpreter.ERROR) {\n      // Called with new.\n      var newError = this;\n    } else {\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\n    }\n    if (opt_message) {\n      thisInterpreter.setProperty(newError, 'message',\n          thisInterpreter.createPrimitive(String(opt_message)), false, true);\n    }\n    return newError;\n  };\n  this.ERROR = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Error', this.ERROR);\n  this.setProperty(this.ERROR.properties.prototype,\n                   'message', this.STRING_EMPTY, false, true);\n  this.setProperty(this.ERROR.properties.prototype,\n                   'name', this.createPrimitive('Error'), false, true);\n\n  // Create half a dozen error subclasses.\n  var errors = {\n    EVAL_ERROR: 'EvalError',\n    RANGE_ERROR: 'RangeError',\n    REFERENCE_ERROR: 'ReferenceError',\n    SYNTAX_ERROR: 'SyntaxError',\n    TYPE_ERROR: 'TypeError',\n    URI_ERROR: 'URIError'\n  };\n  for (var constName in errors) {\n    var errorName = errors[constName];\n    //EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError\n    wrapper = function(name) {\n      return function(opt_message) {\n        if (thisInterpreter.isa(this.parent, thisInterpreter.ERROR)) {\n          // Called with new.\n          var newError = this;\n        } else {\n          var newError = thisInterpreter.createObject(thisInterpreter[name]);\n        }\n        if (opt_message) {\n          thisInterpreter.setProperty(newError, 'message',\n              thisInterpreter.createPrimitive(String(opt_message)), false, true);\n        }\n        return newError;\n      };\n    };\n    this[constName] = this.createNativeFunction(wrapper(constName));\n    this.setProperty(this[constName], 'prototype', this.createObject(this.ERROR));\n    this.setProperty(this[constName].properties.prototype,\n                     'name', this.createPrimitive(errorName), false, true);\n    this.setProperty(scope, errorName, this[constName]);\n  }\n};\n\n/**\n * Is an object of a certain class?\n * @param {Object} child Object to check.\n * @param {Object} parent Constructor of object.\n * @return {boolean} True if object is the class or inherits from it.\n *     False otherwise.\n */\nInterpreter.prototype.isa = function(child, parent) {\n  if (!child || !parent) {\n    return false;\n  }\n  while (child.parent != parent) {\n    if (!child.parent || !child.parent.properties.prototype) {\n      return false;\n    }\n    child = child.parent.properties.prototype;\n  }\n  return true;\n};\n\n/**\n * Compares two objects against each other.\n * @param {!Object} a First object.\n * @param {!Object} b Second object.\n * @return {number} -1 if a is smaller, 0 if a == b, 1 if a is bigger,\n *     NaN if they are not comparable.\n */\nInterpreter.prototype.comp = function(a, b) {\n  if (a.isPrimitive && typeof a == 'number' && isNaN(a.data) ||\n      b.isPrimitive && typeof b == 'number' && isNaN(b.data)) {\n    return NaN;\n  }\n  if (a.isPrimitive && b.isPrimitive) {\n    a = a.data;\n    b = b.data;\n  } else {\n    // TODO: Handle other types.\n    return NaN;\n  }\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Is a value a legal integer for an array?\n * @param {*} n Value to check.\n * @return {number} Zero, or a positive integer if the value can be\n *     converted to such.  NaN otherwise.\n */\nInterpreter.prototype.arrayIndex = function(n) {\n  n = Number(n);\n  if (!isFinite(n) || n != Math.floor(n) || n < 0) {\n    return NaN;\n  }\n  return n;\n};\n\n/**\n * Class for a number, string, boolean, null, or undefined.\n * @param {number|string|boolean|null|undefined} data Primitive value.\n * @param {!Interpreter} interpreter The JS Interpreter to bind to.\n * @constructor\n */\nInterpreter.Primitive = function(data, interpreter) {\n  var type = typeof data;\n  this.data = data;\n  this.type = type;\n  if (type == 'number') {\n    this.parent = interpreter.NUMBER;\n  } else if (type == 'string') {\n    this.parent = interpreter.STRING;\n  } else if (type == 'boolean') {\n    this.parent = interpreter.BOOLEAN;\n  }\n};\n\n/**\n * @type {number|string|boolean|null|undefined}\n */\nInterpreter.Primitive.prototype.data = undefined;\n\n/**\n * @type {string}\n */\nInterpreter.Primitive.prototype.type = undefined;\n\n/**\n * @type {Function}\n */\nInterpreter.Primitive.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Primitive.prototype.isPrimitive = true;\n\n/**\n * Convert this primitive into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Primitive.prototype.toBoolean = function() {\n  return Boolean(this.data);\n};\n\n/**\n * Convert this primitive into a number.\n * @return {number} Number value.\n */\nInterpreter.Primitive.prototype.toNumber = function() {\n  return Number(this.data);\n};\n\n/**\n * Convert this primitive into a string.\n * @return {string} String value.\n */\nInterpreter.Primitive.prototype.toString = function() {\n  return String(this.data);\n};\n\n/**\n * Return the primitive value.\n * @return {number|string|boolean|null|undefined} Primitive value.\n */\nInterpreter.Primitive.prototype.valueOf = function() {\n  return this.data;\n};\n\n/**\n * Create a new data object for a primitive.\n * @param {number|string|boolean|null|undefined|RegExp} data Data to\n *     encapsulate.\n * @return {!Object} New data object.\n */\nInterpreter.prototype.createPrimitive = function(data) {\n  // Reuse a predefined primitive constant if possible.\n  if (data === undefined) {\n    return this.UNDEFINED;\n  } else if (data === null) {\n    return this.NULL;\n  } else if (data === true) {\n    return this.TRUE;\n  } else if (data === false) {\n    return this.FALSE;\n  } else if (data === 0) {\n    return this.NUMBER_ZERO;\n  } else if (data === 1) {\n    return this.NUMBER_ONE;\n  } else if (data === '') {\n    return this.STRING_EMPTY;\n  } else if (data instanceof RegExp) {\n    return this.createRegExp(this.createObject(this.REGEXP), data);\n  }\n  return new Interpreter.Primitive(data, this);\n};\n\n/**\n * Class for an object.\n * @param {Object} parent Parent constructor function.\n * @constructor\n */\nInterpreter.Object = function(parent) {\n  this.fixed = Object.create(null);\n  this.nonenumerable = Object.create(null);\n  this.properties = Object.create(null);\n  this.parent = parent;\n};\n\n/**\n * @type {string}\n */\nInterpreter.Object.prototype.type = 'object';\n\n/**\n * @type {Function}\n */\nInterpreter.Object.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Object.prototype.isPrimitive = false;\n\n/**\n * @type {number|string|boolean|undefined}\n */\nInterpreter.Object.prototype.data = undefined;\n\n/**\n * Convert this object into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Object.prototype.toBoolean = function() {\n  return true;\n};\n\n/**\n * Convert this object into a number.\n * @return {number} Number value.\n */\nInterpreter.Object.prototype.toNumber = function() {\n  return Number(this.data === undefined ? this.toString() : this.data);\n};\n\n/**\n * Convert this object into a string.\n * @return {string} String value.\n */\nInterpreter.Object.prototype.toString = function() {\n  return this.data === undefined ? ('[' + this.type + ']') : String(this.data);\n};\n\n/**\n * Return the object value.\n * @return {!Object} Value.\n */\nInterpreter.Object.prototype.valueOf = function() {\n  return this.data === undefined ? this : this.data;\n};\n\n/**\n * Create a new data object.\n * @param {Object} parent Parent constructor function.\n * @return {!Object} New data object.\n */\nInterpreter.prototype.createObject = function(parent) {\n  var obj = new Interpreter.Object(parent);\n  // Functions have prototype objects.\n  if (this.isa(obj, this.FUNCTION)) {\n    obj.type = 'function';\n    this.setProperty(obj, 'prototype', this.createObject(this.OBJECT || null));\n  }\n  // Arrays have length.\n  if (this.isa(obj, this.ARRAY)) {\n    obj.length = 0;\n    obj.toString = function() {\n      var strs = [];\n      for (var i = 0; i < this.length; i++) {\n        strs[i] = (this.properties[i] == undefined ||\n                   this.properties[i] == null) ?\n                   '' : this.properties[i].toString();\n      }\n      return strs.join(',');\n    };\n  }\n  return obj;\n};\n\n/**\n * Creates a new regular expression object.\n * @param {Object} obj The existing object to set.\n * @param {Object} data The native regular expression.\n * @return {!Object} New regular expression object.\n */\nInterpreter.prototype.createRegExp = function(obj, data) {\n  obj.data = data;\n  // lastIndex is settable, all others are read-only attributes\n  this.setProperty(obj, 'lastIndex', this.createPrimitive(obj.data.lastIndex),\n                   false, true);\n  this.setProperty(obj, 'source', this.createPrimitive(obj.data.source),\n                   true, true);\n  this.setProperty(obj, 'global', this.createPrimitive(obj.data.global),\n                   true, true);\n  this.setProperty(obj, 'ignoreCase', this.createPrimitive(obj.data.ignoreCase),\n                   true, true);\n  this.setProperty(obj, 'multiline', this.createPrimitive(obj.data.multiline),\n                   true, true);\n  // Override a couple of Object's conversion functions.\n  obj.toString = function() {return String(this.data);};\n  obj.valueOf = function() {return this.data;};\n  return obj;\n};\n\n/**\n * Create a new function.\n * @param {Object} node AST node defining the function.\n * @param {Object} opt_scope Optional parent scope.\n * @return {!Object} New function.\n */\nInterpreter.prototype.createFunction = function(node, opt_scope) {\n  var func = this.createObject(this.FUNCTION);\n  func.parentScope = opt_scope || this.getScope();\n  func.node = node;\n  this.setProperty(func, 'length',\n                   this.createPrimitive(func.node.params.length), true);\n  return func;\n};\n\n/**\n * Create a new native function.\n * @param {!Function} nativeFunc JavaScript function.\n * @return {!Object} New function.\n */\nInterpreter.prototype.createNativeFunction = function(nativeFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.nativeFunc = nativeFunc;\n  this.setProperty(func, 'length',\n                   this.createPrimitive(nativeFunc.length), true);\n  return func;\n};\n\n/**\n * Create a new native asynchronous function.\n * @param {!Function} asyncFunc JavaScript function.\n * @return {!Object} New function.\n */\nInterpreter.prototype.createAsyncFunction = function(asyncFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.asyncFunc = asyncFunc;\n  this.setProperty(func, 'length',\n                   this.createPrimitive(asyncFunc.length), true);\n  return func;\n};\n\n/**\n * Fetch a property value from a data object.\n * @param {!Object} obj Data object.\n * @param {*} name Name of property.\n * @return {!Object} Property value (may be UNDEFINED).\n */\nInterpreter.prototype.getProperty = function(obj, name) {\n  name = name.toString();\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot read property '\" + name + \"' of \" + obj);\n  }\n  // Special cases for magic length property.\n  if (this.isa(obj, this.STRING)) {\n    if (name == 'length') {\n      return this.createPrimitive(obj.data.length);\n    }\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return this.createPrimitive(obj.data[n]);\n    }\n  } else if (this.isa(obj, this.ARRAY) && name == 'length') {\n    return this.createPrimitive(obj.length);\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      return obj.properties[name];\n    }\n    if (obj.parent && obj.parent.properties &&\n        obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return this.UNDEFINED;\n};\n\n/**\n * Does the named property exist on a data object.\n * @param {!Object} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if property exists.\n */\nInterpreter.prototype.hasProperty = function(obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive) {\n    throw TypeError('Primitive data type has no properties');\n  }\n  if (name == 'length' &&\n      (this.isa(obj, this.STRING) || this.isa(obj, this.ARRAY))) {\n    return true;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return true;\n    }\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      return true;\n    }\n    if (obj.parent && obj.parent.properties &&\n        obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return false;\n};\n\n/**\n * Set a property value on a data object.\n * @param {!Object} obj Data object.\n * @param {*} name Name of property.\n * @param {!Object} value New property value.\n * @param {boolean} opt_fixed Unchangeable property if true.\n * @param {boolean} opt_nonenum Non-enumerable property if true.\n */\nInterpreter.prototype.setProperty = function(obj, name, value,\n                                             opt_fixed, opt_nonenum) {\n  name = name.toString();\n  if (typeof value != 'object') {\n    throw Error('Failure to wrap a value: ' + value);\n  }\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR,\n                        \"Cannot set property '\" + name + \"' of \" + obj);\n  }\n  if (obj.isPrimitive || obj.fixed[name]) {\n    return;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (name == 'length' || (!isNaN(n) && n < obj.data.length)) {\n      // Can't set length or letters on Strings.\n      return;\n    }\n  }\n  if (this.isa(obj, this.ARRAY)) {\n    // Arrays have a magic length variable that is bound to the elements.\n    var i;\n    if (name == 'length') {\n      // Delete elements if length is smaller.\n      var newLength = this.arrayIndex(value.toNumber());\n      if (isNaN(newLength)) {\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\n      }\n      if (newLength < obj.length) {\n        for (i in obj.properties) {\n          i = this.arrayIndex(i);\n          if (!isNaN(i) && newLength <= i) {\n            delete obj.properties[i];\n          }\n        }\n      }\n      obj.length = newLength;\n      return;  // Don't set a real length property.\n    } else if (!isNaN(i = this.arrayIndex(name))) {\n      // Increase length if this index is larger.\n      obj.length = Math.max(obj.length, i + 1);\n    }\n  }\n  // Set the property.\n  obj.properties[name] = value;\n  if (opt_fixed) {\n    obj.fixed[name] = true;\n  }\n  if (opt_nonenum) {\n    obj.nonenumerable[name] = true;\n  }\n};\n\n/**\n * Delete a property value on a data object.\n * @param {!Object} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if deleted, false if undeletable.\n */\nInterpreter.prototype.deleteProperty = function(obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive || obj.fixed[name]) {\n    return false;\n  }\n  if (name == 'length' && this.isa(obj, this.ARRAY)) {\n    return false;\n  }\n  return delete obj.properties[name];\n};\n\n/**\n * Returns the current scope from the stateStack.\n * @return {!Object} Current scope dictionary.\n */\nInterpreter.prototype.getScope = function() {\n  for (var i = 0; i < this.stateStack.length; i++) {\n    if (this.stateStack[i].scope) {\n      return this.stateStack[i].scope;\n    }\n  }\n  throw Error('No scope found.');\n};\n\n/**\n * Create a new scope dictionary.\n * @param {!Object} node AST node defining the scope container\n *     (e.g. a function).\n * @param {Object} parentScope Scope to link to.\n * @return {!Object} New scope.\n */\nInterpreter.prototype.createScope = function(node, parentScope) {\n  var scope = this.createObject(null);\n  scope.parentScope = parentScope;\n  if (!parentScope) {\n    this.initGlobalScope(scope);\n  }\n  this.populateScope_(node, scope);\n\n  // Determine if this scope starts with 'use strict'.\n  scope.strict = false;\n  if (parentScope && parentScope.strict) {\n    scope.strict = true;\n  } else {\n    var firstNode = node.body && node.body[0];\n    if (firstNode && firstNode.expression &&\n        firstNode.expression.type == 'Literal' &&\n        firstNode.expression.value == 'use strict') {\n      scope.strict = true;\n    }\n  }\n  return scope;\n};\n\n/**\n * Create a new special scope dictionary. Similar to createScope(), but\n * doesn't assume that the scope is for a function body. This is used for\n * the catch clause and with statement.\n * @param {!Object} parentScope Scope to link to.\n * @param {Object=} opt_scope Optional object to transform into scope.\n * @return {!Object} New scope.\n */\nInterpreter.prototype.createSpecialScope = function(parentScope, opt_scope) {\n  if (!parentScope) {\n    throw Error('parentScope required');\n  }\n  var scope = opt_scope || this.createObject(null);\n  scope.parentScope = parentScope;\n  scope.strict = parentScope.strict;\n  return scope;\n};\n\n\n/**\n * Retrieves a value from the scope chain.\n * @param {!Object} name Name of variable.\n * @return {!Object} The value.\n */\nInterpreter.prototype.getValueFromScope = function(name) {\n  var scope = this.getScope();\n  var nameStr = name.toString();\n  while (scope) {\n    if (nameStr in scope.properties) {\n      return scope.properties[nameStr];\n    }\n    scope = scope.parentScope;\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n  return this.UNDEFINED;\n};\n\n/**\n * Sets a value to the current scope.\n * @param {!Object} name Name of variable.\n * @param {!Object} value Value.\n */\nInterpreter.prototype.setValueToScope = function(name, value) {\n  var scope = this.getScope();\n  var strict = scope.strict;\n  var nameStr = name.toString();\n  while (scope) {\n    if ((nameStr in scope.properties) || (!strict && !scope.parentScope)) {\n      if (!scope.fixed[nameStr]) {\n        scope.properties[nameStr] = value;\n      }\n      return;\n    }\n    scope = scope.parentScope;\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n};\n\n/**\n * Create a new scope for the given node.\n * @param {!Object} node AST node (program or function).\n * @param {!Object} scope Scope dictionary to populate.\n * @private\n */\nInterpreter.prototype.populateScope_ = function(node, scope) {\n  if (node.type == 'VariableDeclaration') {\n    for (var i = 0; i < node.declarations.length; i++) {\n      this.setProperty(scope, node.declarations[i].id.name, this.UNDEFINED);\n    }\n  } else if (node.type == 'FunctionDeclaration') {\n    this.setProperty(scope, node.id.name, this.createFunction(node, scope));\n    return;  // Do not recurse into function.\n  } else if (node.type == 'FunctionExpression') {\n    return;  // Do not recurse into function.\n  }\n  var thisIterpreter = this;\n  function recurse(child) {\n    if (child.constructor == thisIterpreter.ast.constructor) {\n      thisIterpreter.populateScope_(child, scope);\n    }\n  }\n  for (var name in node) {\n    var prop = node[name];\n    if (prop && typeof prop == 'object') {\n      if (typeof prop.length == 'number' && prop.splice) {\n        // Prop is an array.\n        for (var i = 0; i < prop.length; i++) {\n          recurse(prop[i]);\n        }\n      } else {\n        recurse(prop);\n      }\n    }\n  }\n};\n\n/**\n * Gets a value from the scope chain or from an object property.\n * @param {!Object|!Array} left Name of variable or object/propname tuple.\n * @return {!Object} Value.\n */\nInterpreter.prototype.getValue = function(left) {\n  if (left.length) {\n    var obj = left[0];\n    var prop = left[1];\n    return this.getProperty(obj, prop);\n  } else {\n    return this.getValueFromScope(left);\n  }\n};\n\n/**\n * Sets a value to the scope chain or to an object property.\n * @param {!Object|!Array} left Name of variable or object/propname tuple.\n * @param {!Object} value Value.\n */\nInterpreter.prototype.setValue = function(left, value) {\n  if (left.length) {\n    var obj = left[0];\n    var prop = left[1];\n    this.setProperty(obj, prop, value);\n  } else {\n    this.setValueToScope(left, value);\n  }\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.  Can be called with either an error class and a message, or\n * with an actual object to be thrown.\n * @param {!Object} errorClass Type of error (if message is provided) or the\n *   value to throw (if no message).\n * @param {string} opt_message Message being thrown.\n */\nInterpreter.prototype.throwException = function(errorClass, opt_message) {\n  if (this.stateStack[0].interpreter) {\n    // This is the wrong interpreter, we are spinning on an eval.\n    try {\n      this.stateStack[0].interpreter.throwException(errorClass, opt_message);\n      return;\n    } catch (e) {\n      // The eval threw an error and did not catch it.\n      // Continue to see if this level can catch it.\n    }\n  }\n  if (opt_message === undefined) {\n    var error = errorClass;\n  } else {\n    var error = this.createObject(errorClass);\n    this.setProperty(error, 'message',\n        this.createPrimitive(opt_message), false, true);\n  }\n  // Search for a try statement.\n  do {\n    var state = this.stateStack.shift();\n  } while (state && state.node.type !== 'TryStatement');\n  if (state) {\n    // Error is being trapped.\n    this.stateStack.unshift({\n      node: state.node.handler,\n      throwValue: error\n    });\n  } else {\n    // Throw a real error.\n    var realError;\n    if (this.isa(error, this.ERROR)) {\n      var errorTable = {\n        'EvalError': EvalError,\n        'RangeError': RangeError,\n        'ReferenceError': ReferenceError,\n        'SyntaxError': SyntaxError,\n        'TypeError': TypeError,\n        'URIError': URIError\n      };\n      var type = errorTable[this.getProperty(error, 'name')] || Error;\n      realError = type(this.getProperty(error, 'message'));\n    } else {\n      realError = error.toString();\n    }\n    throw realError;\n  }\n};\n\n// Functions to handle each node type.\n\nInterpreter.prototype['stepArrayExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (!state.array) {\n    state.array = this.createObject(this.ARRAY);\n  } else {\n    this.setProperty(state.array, n - 1, state.value);\n  }\n  if (node.elements[n]) {\n    state.n = n + 1;\n    this.stateStack.unshift({node: node.elements[n]});\n  } else {\n    state.array.length = state.n || 0;\n    this.stateStack.shift();\n    this.stateStack[0].value = state.array;\n  }\n};\n\nInterpreter.prototype['stepAssignmentExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneLeft) {\n    state.doneLeft = true;\n    this.stateStack.unshift({node: node.left, components: true});\n  } else if (!state.doneRight) {\n    state.doneRight = true;\n    state.leftSide = state.value;\n    this.stateStack.unshift({node: node.right});\n  } else {\n    this.stateStack.shift();\n    var leftSide = state.leftSide;\n    var rightSide = state.value;\n    var value;\n    if (node.operator == '=') {\n      value = rightSide;\n    } else {\n      var leftValue = this.getValue(leftSide);\n      var rightValue = rightSide;\n      var leftNumber = leftValue.toNumber();\n      var rightNumber = rightValue.toNumber();\n      if (node.operator == '+=') {\n        var left, right;\n        if (leftValue.type == 'string' || rightValue.type == 'string') {\n          left = leftValue.toString();\n          right = rightValue.toString();\n        } else {\n          left = leftNumber;\n          right = rightNumber;\n        }\n        value = left + right;\n      } else if (node.operator == '-=') {\n        value = leftNumber - rightNumber;\n      } else if (node.operator == '*=') {\n        value = leftNumber * rightNumber;\n      } else if (node.operator == '/=') {\n        value = leftNumber / rightNumber;\n      } else if (node.operator == '%=') {\n        value = leftNumber % rightNumber;\n      } else if (node.operator == '<<=') {\n        value = leftNumber << rightNumber;\n      } else if (node.operator == '>>=') {\n        value = leftNumber >> rightNumber;\n      } else if (node.operator == '>>>=') {\n        value = leftNumber >>> rightNumber;\n      } else if (node.operator == '&=') {\n        value = leftNumber & rightNumber;\n      } else if (node.operator == '^=') {\n        value = leftNumber ^ rightNumber;\n      } else if (node.operator == '|=') {\n        value = leftNumber | rightNumber;\n      } else {\n        throw SyntaxError('Unknown assignment expression: ' + node.operator);\n      }\n      value = this.createPrimitive(value);\n    }\n    this.setValue(leftSide, value);\n    this.stateStack[0].value = value;\n  }\n};\n\nInterpreter.prototype['stepBinaryExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneLeft) {\n    state.doneLeft = true;\n    this.stateStack.unshift({node: node.left});\n  } else if (!state.doneRight) {\n    state.doneRight = true;\n    state.leftValue = state.value;\n    this.stateStack.unshift({node: node.right});\n  } else {\n    this.stateStack.shift();\n    var leftSide = state.leftValue;\n    var rightSide = state.value;\n    var value;\n    var comp = this.comp(leftSide, rightSide);\n    if (node.operator == '==' || node.operator == '!=') {\n      if (leftSide.isPrimitive && rightSide.isPrimitive) {\n        value = leftSide.data == rightSide.data;\n      } else {\n        value = comp === 0;\n      }\n      if (node.operator == '!=') {\n        value = !value;\n      }\n    } else if (node.operator == '===' || node.operator == '!==') {\n      if (leftSide.isPrimitive && rightSide.isPrimitive) {\n        value = leftSide.data === rightSide.data;\n      } else {\n        value = leftSide === rightSide;\n      }\n      if (node.operator == '!==') {\n        value = !value;\n      }\n    } else if (node.operator == '>') {\n      value = comp == 1;\n    } else if (node.operator == '>=') {\n      value = comp == 1 || comp === 0;\n    } else if (node.operator == '<') {\n      value = comp == -1;\n    } else if (node.operator == '<=') {\n      value = comp == -1 || comp === 0;\n    } else if (node.operator == '+') {\n      if (leftSide.type == 'string' || rightSide.type == 'string') {\n        var leftValue = leftSide.toString();\n        var rightValue = rightSide.toString();\n      } else {\n        var leftValue = leftSide.toNumber();\n        var rightValue = rightSide.toNumber();\n      }\n      value = leftValue + rightValue;\n    } else if (node.operator == 'in') {\n      value = this.hasProperty(rightSide, leftSide);\n    } else if (node.operator == 'instanceof') {\n      if (!this.isa(rightSide, this.FUNCTION)) {\n        this.throwException(this.TYPE_ERROR,\n            'Expecting a function in instanceof check');\n      }\n      value = this.isa(leftSide, rightSide);\n    } else {\n      var leftValue = leftSide.toNumber();\n      var rightValue = rightSide.toNumber();\n      if (node.operator == '-') {\n        value = leftValue - rightValue;\n      } else if (node.operator == '*') {\n        value = leftValue * rightValue;\n      } else if (node.operator == '/') {\n        value = leftValue / rightValue;\n      } else if (node.operator == '%') {\n        value = leftValue % rightValue;\n      } else if (node.operator == '&') {\n        value = leftValue & rightValue;\n      } else if (node.operator == '|') {\n        value = leftValue | rightValue;\n      } else if (node.operator == '^') {\n        value = leftValue ^ rightValue;\n      } else if (node.operator == '<<') {\n        value = leftValue << rightValue;\n      } else if (node.operator == '>>') {\n        value = leftValue >> rightValue;\n      } else if (node.operator == '>>>') {\n        value = leftValue >>> rightValue;\n      } else {\n        throw SyntaxError('Unknown binary operator: ' + node.operator);\n      }\n    }\n    this.stateStack[0].value = this.createPrimitive(value);\n  }\n};\n\nInterpreter.prototype['stepBlockStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.body[n]) {\n    state.done = false;\n    state.n_ = n + 1;\n    this.stateStack.unshift({node: node.body[n]});\n  } else {\n    state.done = true;\n    if (state.node.type != 'Program') {\n      // Leave the root scope on the tree in case the program is appended to.\n      this.stateStack.shift();\n    }\n  }\n};\n\nInterpreter.prototype['stepBreakStatement'] = function() {\n  var state = this.stateStack.shift();\n  var node = state.node;\n  var label = null;\n  if (node.label) {\n    label = node.label.name;\n  }\n  state = this.stateStack.shift();\n  while (state &&\n         state.node.type != 'CallExpression' &&\n         state.node.type != 'NewExpression') {\n    if (label ? label == state.label : (state.isLoop || state.isSwitch)) {\n      return;\n    }\n    state = this.stateStack.shift();\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal break statement');\n};\n\nInterpreter.prototype['stepCallExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneCallee_) {\n    state.doneCallee_ = true;\n    this.stateStack.unshift({node: node.callee, components: true});\n  } else {\n    if (!state.func_) {\n      // Determine value of the function.\n      if (state.value.type == 'function') {\n        state.func_ = state.value;\n      } else {\n        if (state.value.length) {\n          state.member_ = state.value[0];\n        }\n        state.func_ = this.getValue(state.value);\n        if (!state.func_ || state.func_.type != 'function') {\n          this.throwException(this.TYPE_ERROR,\n              (state.value && state.value.type) + ' is not a function');\n          return;\n        }\n      }\n      // Determine value of 'this' in function.\n      if (state.node.type == 'NewExpression') {\n        state.funcThis_ = this.createObject(state.func_);\n        state.isConstructor_ = true;\n      } else if (state.value.length) {\n        state.funcThis_ = state.value[0];\n      } else {\n        state.funcThis_ =\n            this.stateStack[this.stateStack.length - 1].thisExpression;\n      }\n      state.arguments = [];\n      var n = 0;\n    } else {\n      var n = state.n_;\n      if (state.arguments.length != node.arguments.length) {\n        state.arguments[n - 1] = state.value;\n      }\n    }\n    if (node.arguments[n]) {\n      state.n_ = n + 1;\n      this.stateStack.unshift({node: node.arguments[n]});\n    } else if (!state.doneExec) {\n      state.doneExec = true;\n      if (state.func_.node &&\n          (state.func_.node.type == 'FunctionApply_' ||\n           state.func_.node.type == 'FunctionCall_')) {\n        state.funcThis_ = state.arguments.shift();\n        if (state.func_.node.type == 'FunctionApply_') {\n          // Unpack all the arguments from the provided array.\n          var argsList = state.arguments.shift();\n          if (argsList && this.isa(argsList, this.ARRAY)) {\n            state.arguments = [];\n            for (var i = 0; i < argsList.length; i++) {\n              state.arguments[i] = this.getProperty(argsList, i);\n            }\n          } else {\n            state.arguments = [];\n          }\n        }\n        state.func_ = state.member_;\n      }\n      if (state.func_.node) {\n        var scope =\n            this.createScope(state.func_.node.body, state.func_.parentScope);\n        // Add all arguments.\n        for (var i = 0; i < state.func_.node.params.length; i++) {\n          var paramName = this.createPrimitive(state.func_.node.params[i].name);\n          var paramValue = state.arguments.length > i ? state.arguments[i] :\n              this.UNDEFINED;\n          this.setProperty(scope, paramName, paramValue);\n        }\n        // Build arguments variable.\n        var argsList = this.createObject(this.ARRAY);\n        for (var i = 0; i < state.arguments.length; i++) {\n          this.setProperty(argsList, this.createPrimitive(i),\n                           state.arguments[i]);\n        }\n        this.setProperty(scope, 'arguments', argsList);\n        var funcState = {\n          node: state.func_.node.body,\n          scope: scope,\n          thisExpression: state.funcThis_\n        };\n        this.stateStack.unshift(funcState);\n        state.value = this.UNDEFINED;  // Default value if no explicit return.\n      } else if (state.func_.nativeFunc) {\n        state.value = state.func_.nativeFunc.apply(state.funcThis_,\n                                                   state.arguments);\n      } else if (state.func_.asyncFunc) {\n        var thisInterpreter = this;\n        var callback = function(value) {\n          state.value = value || thisInterpreter.UNDEFINED;\n          thisInterpreter.paused_ = false;\n        };\n        var argsWithCallback = state.arguments.concat(callback);\n        state.func_.asyncFunc.apply(state.funcThis_, argsWithCallback);\n        this.paused_ = true;\n        return;\n      } else if (state.func_.eval) {\n        var code = state.arguments[0];\n        if (!code) {\n          state.value = this.UNDEFINED;\n        } else if (!code.isPrimitive) {\n          // JS does not parse String objects:\n          // eval(new String('1 + 1')) -> '1 + 1'\n          state.value = code;\n        } else {\n          var evalInterpreter = new Interpreter(code.toString());\n          evalInterpreter.stateStack[0].scope.parentScope = this.getScope();\n          state = {\n            node: {type: 'Eval_'},\n            interpreter: evalInterpreter\n          };\n          this.stateStack.unshift(state);\n        }\n      } else {\n        throw TypeError('function not a function (huh?)');\n      }\n    } else {\n      this.stateStack.shift();\n      if (state.isConstructor_ && state.value.type !== 'object') {\n        this.stateStack[0].value = state.funcThis_;\n      } else {\n        this.stateStack[0].value = state.value;\n      }\n    }\n  }\n};\n\nInterpreter.prototype['stepCatchClause'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneBody) {\n    state.doneBody = true;\n    var scope;\n    if (node.param) {\n      scope = this.createSpecialScope(this.getScope());\n      // Add the argument.\n      var paramName = this.createPrimitive(node.param.name);\n      this.setProperty(scope, paramName, state.throwValue);\n    }\n    this.stateStack.unshift({node: node.body, scope: scope});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepConditionalExpression'] = function() {\n  var state = this.stateStack[0];\n  if (!state.done) {\n    if (!state.test) {\n      state.test = true;\n      this.stateStack.unshift({node: state.node.test});\n    } else {\n      state.done = true;\n      if (state.value.toBoolean() && state.node.consequent) {\n        this.stateStack.unshift({node: state.node.consequent});\n      } else if (!state.value.toBoolean() && state.node.alternate) {\n        this.stateStack.unshift({node: state.node.alternate});\n      }\n    }\n  } else {\n    this.stateStack.shift();\n    if (state.node.type == 'ConditionalExpression') {\n      this.stateStack[0].value = state.value;\n    }\n  }\n};\n\nInterpreter.prototype['stepContinueStatement'] = function() {\n  var node = this.stateStack[0].node;\n  var label = null;\n  if (node.label) {\n    label = node.label.name;\n  }\n  var state = this.stateStack[0];\n  while (state &&\n         state.node.type != 'CallExpression' &&\n         state.node.type != 'NewExpression') {\n    if (state.isLoop) {\n      if (!label || (label == state.label)) {\n        return;\n      }\n    }\n    this.stateStack.shift();\n    state = this.stateStack[0];\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal continue statement');\n};\n\nInterpreter.prototype['stepDoWhileStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  if (state.node.type == 'DoWhileStatement' && state.test === undefined) {\n    // First iteration of do/while executes without checking test.\n    state.value = this.TRUE;\n    state.test = true;\n  }\n  if (!state.test) {\n    state.test = true;\n    this.stateStack.unshift({node: state.node.test});\n  } else {\n    state.test = false;\n    if (!state.value.toBoolean()) {\n      this.stateStack.shift();\n    } else if (state.node.body) {\n      this.stateStack.unshift({node: state.node.body});\n    }\n  }\n};\n\nInterpreter.prototype['stepEmptyStatement'] = function() {\n  this.stateStack.shift();\n};\n\nInterpreter.prototype['stepEval_'] = function() {\n  var state = this.stateStack[0];\n  if (!state.interpreter.step()) {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.interpreter.value || this.UNDEFINED;\n  }\n};\n\nInterpreter.prototype['stepExpressionStatement'] = function() {\n  var state = this.stateStack[0];\n  if (!state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: state.node.expression});\n  } else {\n    this.stateStack.shift();\n    // Save this value to the interpreter for use as a return value if\n    // this code is inside an eval function.\n    this.value = state.value;\n  }\n};\n\nInterpreter.prototype['stepForInStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  var node = state.node;\n  if (!state.doneVariable_) {\n    state.doneVariable_ = true;\n    var left = node.left;\n    if (left.type == 'VariableDeclaration') {\n      // Inline variable declaration: for (var x in y)\n      left = left.declarations[0].id;\n    }\n    this.stateStack.unshift({node: left, components: true});\n  } else if (!state.doneObject_) {\n    state.doneObject_ = true;\n    state.variable = state.value;\n    this.stateStack.unshift({node: node.right});\n  } else {\n    if (typeof state.iterator == 'undefined') {\n      // First iteration.\n      state.object = state.value;\n      state.iterator = 0;\n    }\n    var name = null;\n    done: do {\n      var i = state.iterator;\n      for (var prop in state.object.properties) {\n        if (prop in state.object.nonenumerable) {\n          continue;\n        }\n        if (i == 0) {\n          name = prop;\n          break done;\n        }\n        i--;\n      }\n      state.object = state.object.parent &&\n          state.object.parent.properties.prototype;\n      state.iterator = 0;\n    } while (state.object);\n    state.iterator++;\n    if (name === null) {\n      this.stateStack.shift();\n    } else {\n      this.setValueToScope(state.variable, this.createPrimitive(name));\n      if (node.body) {\n        this.stateStack.unshift({node: node.body});\n      }\n    }\n  }\n};\n\nInterpreter.prototype['stepForStatement'] = function() {\n  var state = this.stateStack[0];\n  state.isLoop = true;\n  var node = state.node;\n  var mode = state.mode || 0;\n  if (mode == 0) {\n    state.mode = 1;\n    if (node.init) {\n      this.stateStack.unshift({node: node.init});\n    }\n  } else if (mode == 1) {\n    state.mode = 2;\n    if (node.test) {\n      this.stateStack.unshift({node: node.test});\n    }\n  } else if (mode == 2) {\n    state.mode = 3;\n    if (node.test && state.value && !state.value.toBoolean()) {\n      // Loop complete.  Bail out.\n      this.stateStack.shift();\n    } else if (node.body) {\n      this.stateStack.unshift({node: node.body});\n    }\n  } else if (mode == 3) {\n    state.mode = 1;\n    if (node.update) {\n      this.stateStack.unshift({node: node.update});\n    }\n  }\n};\n\nInterpreter.prototype['stepFunctionDeclaration'] = function() {\n  this.stateStack.shift();\n};\n\nInterpreter.prototype['stepFunctionExpression'] = function() {\n  var state = this.stateStack.shift();\n  this.stateStack[0].value = this.createFunction(state.node);\n};\n\nInterpreter.prototype['stepIdentifier'] = function() {\n  var state = this.stateStack.shift();\n  var name = this.createPrimitive(state.node.name);\n  this.stateStack[0].value =\n      state.components ? name : this.getValueFromScope(name);\n};\n\nInterpreter.prototype['stepIfStatement'] =\n    Interpreter.prototype['stepConditionalExpression'];\n\nInterpreter.prototype['stepLabeledStatement'] = function() {\n  // No need to hit this node again on the way back up the stack.\n  var state = this.stateStack.shift();\n  this.stateStack.unshift({node: state.node.body,\n                          label: state.node.label.name});\n};\n\nInterpreter.prototype['stepLiteral'] = function() {\n  var state = this.stateStack.shift();\n  this.stateStack[0].value = this.createPrimitive(state.node.value);\n};\n\nInterpreter.prototype['stepLogicalExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.operator != '&&' && node.operator != '||') {\n    throw SyntaxError('Unknown logical operator: ' + node.operator);\n  }\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.unshift({node: node.left});\n  } else if (!state.doneRight_) {\n    if ((node.operator == '&&' && !state.value.toBoolean()) ||\n        (node.operator == '||' && state.value.toBoolean())) {\n      // Shortcut evaluation.\n      this.stateStack.shift();\n      this.stateStack[0].value = state.value;\n    } else {\n      state.doneRight_ = true;\n      this.stateStack.unshift({node: node.right});\n    }\n  } else {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepMemberExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    this.stateStack.unshift({node: node.object});\n  } else if (!state.doneProperty_) {\n    state.doneProperty_ = true;\n    state.object = state.value;\n    this.stateStack.unshift({\n      node: node.property,\n      components: !node.computed\n    });\n  } else {\n    this.stateStack.shift();\n    if (state.components) {\n      this.stateStack[0].value = [state.object, state.value];\n    } else {\n      this.stateStack[0].value = this.getProperty(state.object, state.value);\n    }\n  }\n};\n\nInterpreter.prototype['stepNewExpression'] =\n    Interpreter.prototype['stepCallExpression'];\n\nInterpreter.prototype['stepObjectExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var valueToggle = state.valueToggle;\n  var n = state.n || 0;\n  if (!state.object) {\n    state.object = this.createObject(this.OBJECT);\n  } else {\n    if (valueToggle) {\n      state.key = state.value;\n    } else {\n      this.setProperty(state.object, state.key, state.value);\n    }\n  }\n  if (node.properties[n]) {\n    if (valueToggle) {\n      state.n = n + 1;\n      this.stateStack.unshift({node: node.properties[n].value});\n    } else {\n      this.stateStack.unshift({node: node.properties[n].key, components: true});\n    }\n    state.valueToggle = !valueToggle;\n  } else {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.object;\n  }\n};\n\nInterpreter.prototype['stepProgram'] =\n    Interpreter.prototype['stepBlockStatement'];\n\nInterpreter.prototype['stepReturnStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.argument && !state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: node.argument});\n  } else {\n    var value = state.value || this.UNDEFINED;\n    do {\n      this.stateStack.shift();\n      if (this.stateStack.length == 0) {\n        // Syntax error, do not allow this error to be trapped.\n        throw SyntaxError('Illegal return statement');\n      }\n      state = this.stateStack[0];\n    } while (state.node.type != 'CallExpression' &&\n             state.node.type != 'NewExpression');\n    state.value = value;\n  }\n};\n\nInterpreter.prototype['stepSequenceExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (node.expressions[n]) {\n    state.n = n + 1;\n    this.stateStack.unshift({node: node.expressions[n]});\n  } else {\n    this.stateStack.shift();\n    this.stateStack[0].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepSwitchStatement'] = function() {\n  var state = this.stateStack[0];\n  state.checked = state.checked || [];\n  state.isSwitch = true;\n\n  if (!state.test) {\n    state.test = true;\n    this.stateStack.unshift({node: state.node.discriminant});\n  } else {\n    if (!state.switchValue) {\n      // Preserve switch value between case tests.\n      state.switchValue = state.value;\n    }\n\n    var index = state.index || 0;\n    var currentCase = state.node.cases[index];\n    if (currentCase) {\n      if (!state.done && !state.checked[index] && currentCase.test) {\n        state.checked[index] = true;\n        this.stateStack.unshift({node: currentCase.test});\n      } else {\n        // Test on the default case will be null.\n        if (state.done || !currentCase.test ||\n            this.comp(state.value, state.switchValue) == 0) {\n          state.done = true;\n          var n = state.n || 0;\n          if (currentCase.consequent[n]) {\n            this.stateStack.unshift({node: currentCase.consequent[n]});\n            state.n = n + 1;\n            return;\n          }\n        }\n        state.n = 0;\n        state.index = index + 1;\n      }\n    } else {\n      this.stateStack.shift();\n    }\n  }\n};\n\nInterpreter.prototype['stepThisExpression'] = function() {\n  this.stateStack.shift();\n  for (var i = 0; i < this.stateStack.length; i++) {\n    if (this.stateStack[i].thisExpression) {\n      this.stateStack[0].value = this.stateStack[i].thisExpression;\n      return;\n    }\n  }\n  throw Error('No this expression found.');\n};\n\nInterpreter.prototype['stepThrowStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.argument) {\n    state.argument = true;\n    this.stateStack.unshift({node: node.argument});\n  } else {\n    this.throwException(state.value);\n  }\n};\n\nInterpreter.prototype['stepTryStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneBlock) {\n    state.doneBlock = true;\n    this.stateStack.unshift({node: node.block});\n  } else if (!state.doneFinalizer && node.finalizer) {\n    state.doneFinalizer = true;\n    this.stateStack.unshift({node: node.finalizer});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepUnaryExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.done) {\n    state.done = true;\n    var nextState = {node: node.argument};\n    if (node.operator == 'delete') {\n      nextState.components = true;\n    }\n    this.stateStack.unshift(nextState);\n  } else {\n    this.stateStack.shift();\n    var value;\n    if (node.operator == '-') {\n      value = -state.value.toNumber();\n    } else if (node.operator == '+') {\n      value = state.value.toNumber();\n    } else if (node.operator == '!') {\n      value = !state.value.toBoolean();\n    } else if (node.operator == '~') {\n      value = ~state.value.toNumber();\n    } else if (node.operator == 'typeof') {\n      value = state.value.type;\n    } else if (node.operator == 'delete') {\n      if (state.value.length) {\n        var obj = state.value[0];\n        var name = state.value[1];\n      } else {\n        var obj = this.getScope();\n        var name = state.value;\n      }\n      value = this.deleteProperty(obj, name);\n    } else if (node.operator == 'void') {\n      value = undefined;\n    } else {\n      throw SyntaxError('Unknown unary operator: ' + node.operator);\n    }\n    this.stateStack[0].value = this.createPrimitive(value);\n  }\n};\n\nInterpreter.prototype['stepUpdateExpression'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: node.argument, components: true});\n  } else {\n    this.stateStack.shift();\n    var leftSide = state.value;\n    var leftValue = this.getValue(leftSide).toNumber();\n    var changeValue;\n    if (node.operator == '++') {\n      changeValue = this.createPrimitive(leftValue + 1);\n    } else if (node.operator == '--') {\n      changeValue = this.createPrimitive(leftValue - 1);\n    } else {\n      throw SyntaxError('Unknown update expression: ' + node.operator);\n    }\n    this.setValue(leftSide, changeValue);\n    this.stateStack[0].value = node.prefix ?\n        changeValue : this.createPrimitive(leftValue);\n  }\n};\n\nInterpreter.prototype['stepVariableDeclaration'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  var n = state.n || 0;\n  if (node.declarations[n]) {\n    state.n = n + 1;\n    this.stateStack.unshift({node: node.declarations[n]});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepVariableDeclarator'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (node.init && !state.done) {\n    state.done = true;\n    this.stateStack.unshift({node: node.init});\n  } else {\n    if (!this.hasProperty(this, node.id.name) || node.init) {\n      var value = node.init ? state.value : this.UNDEFINED;\n      this.setValue(this.createPrimitive(node.id.name), value);\n    }\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepWithStatement'] = function() {\n  var state = this.stateStack[0];\n  var node = state.node;\n  if (!state.doneObject) {\n    state.doneObject = true;\n    this.stateStack.unshift({node: node.object});\n  } else if (!state.doneBody) {\n    state.doneBody = true;\n    var scope = this.createSpecialScope(this.getScope(), state.value);\n    this.stateStack.unshift({node: node.body, scope: scope});\n  } else {\n    this.stateStack.shift();\n  }\n};\n\nInterpreter.prototype['stepWhileStatement'] =\n    Interpreter.prototype['stepDoWhileStatement'];\n\n// Preserve top-level API functions from being pruned by JS compilers.\n// Add others as needed.\n// The global object ('window' in a browser, 'global' in node.js) is 'this'.\nthis['Interpreter'] = Interpreter;\nInterpreter.prototype['appendCode'] = Interpreter.prototype.appendCode;\nInterpreter.prototype['step'] = Interpreter.prototype.step;\nInterpreter.prototype['run'] = Interpreter.prototype.run;\n"]}